# 버블 정렬, 선택 정렬, 삽입 정렬

## 버블 정렬이란 무엇인가요?

인접한 두 요소를 비교해 더 큰 값을 오른쪽으로 보내는 방식의 정렬.
한 번 반복할 때마다 가장 큰 값이 뒤로 거품처럼 밀려나서 버블 정렬.

- 안정 정렬
  - 동일한 값을 가진 요소들의 상대적인 순서가 정렬 후에도 유지되는 정렬
  - 거품 정렬은 인접한 두 요소를 비교하면서 swap(교환)하기 때문에 동일한 값을 가진 요소가 있다면 뒤에 있는 요소가 앞의 요소를 넘어서지 않음

## 버블 정렬의 시간복잡도는 어떻게 되나요?

최악/평균/최선 모두 O(n²)
구현하기 가장 간단하나, 이미 정렬된 경우에도 불필요한 비교를 하므로 비효율적.

## JS에서 버블 정렬 구현은 어떻게 하나요?

```js
function bubbleSort(arr) {
  const len = arr.length;
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
```

## 선택 정렬이란 무엇인가요?

주어진 리스트에서 가장 작은 값을 선택해 맨 앞에 놓는 방식의 정렬.
각 단계마다 최소값을 찾아 자리 바꿈.

- 구현이 쉽고 직관적
- 불필요한 교환이 적기때문에 메모리 이동 비용이 중요한 환경에선 유리
- 불안정 정렬 → 동일한 값의 순서가 변경될 수 있음

## 선택 정렬의 시간복잡도는?

최악, 평균, 최선 모두 O(n²)  
다만 교환 횟수는 적기 때문에 버블보다는 조금 더 나은 경우도 있음

- 비교 횟수는 N(N-1)/2 (항상 일정)
- 교환 횟수는 N-1 (최소한의 스왑 발생)

## 삽입 정렬이란 무엇인가요?

정렬된 부분 리스트에 새로운 값을 적절한 위치에 삽입하는 방식의 정렬.

1. 두 번째 원소부터 시작해, 앞쪽의 정렬된 부분에서 적절한 위치를 찾음
2. 정렬된 부분에서 자기보다 큰/작은 원소들은 한 칸씩 뒤로 밀고, 찾은 위치에 삽입
3. 이 과정을 마지막 원소까지 반복
   흔히 카드 게임에서 손에 쥐고 정렬하는 방식과 유사하다고 함.

사용하는 경우:

- 거의 정렬되어 있는 데이터
- 요소 수가 적은 경우
- 실시간 데이터 정렬 (부분 정렬 필요 시)

특징:

- 매 순간 정렬된 부분을 유지 → "온라인 정렬(Online Sort)" 가능
- 교환 횟수가 많음 → 새로운 값을 삽입하기 위해 원소를 이동해야 함
- 안정 정렬 → 동일한 값의 순서를 유지함

## 삽입 정렬의 시간복잡도는?

평균/최악: O(n²), 최선(이미 정렬된 경우): O(n)
부분적으로 정렬된 데이터에 대해 효율적

## 삽입 정렬의 JS 구현은 어떤 식인가요?

```js
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let j = i - 1;
    let current = arr[i];
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = current;
  }
  return arr;
}
```
