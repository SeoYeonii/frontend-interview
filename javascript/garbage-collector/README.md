# 가비지컬랙터

## 자바스크립트 가비지컬렉터

가비지 컬렉터는 더 이상 참조되지 않는 객체를 탐지하여 메모리에서 해제하는 역할을 함. (메모리 할당을 추적하고 할당된 메모리 영역이 필요하지 않은 영역일 경우를 판단해서 회수) C나 C++와 달리 자바스크립트는 필요한 메모리를 자동으로 할당하고 더 이상 사용하지 않는 메모리는 자동으로 회수하므로 개발자가 직접 메모리를 관리하지 않아도 됨

자바스크립트에서는 어떤 다른 오브젝트도 참조하지 않는 오브젝트가 생기면 가비지 콜렉션을 수행

## 가비지 컬렉터의 역할은? 어떻게 작동하는가?

GC는 메모리 해제가 가능한 데이터를 찾아 자동으로 제거

알고리즘.

- 참조 카운팅(Reference Counting): 객체가 참조되는 수를 기준으로 제거할지 판단. 순환 참조 문제에 취약.

  - 카운팅 방법
    1. 변수를 선언하고 참조 값이 할당되면 참조 카운트는 1.
    2. 다른 변수가 같은 값을 참조하면 참조 카운트 ++;
    3. 마찬가지로 해당 값을 참조하는 변수에 다른 값을 할당하면 원래 값의 참조 카운트 --;
    4. 값의 참조 카운트가 0이 되면 해당 값에 접근할 방법이 없으며, 메모리를 회수해도 안전
    5. 다음 가비지 컬렉터를 실행할 때 참조 카운트가 0인 값에서 사용하던 메모리를 회수.
  - 순환참조

    ```tsx
    function f() {
      var o = {};
      var o2 = {};
      o.a = o2; // o는 o2를 참조한다.
      o2.a = o; // o2는 o를 참조한다.

      return "azerty";
    }

    f();
    ```

    두 객체가 서로 참조하는 속성으로 생성되어 순환 구조를 생성. 함수 호출이 완료되면 이 두 객체는 스코프를 벗어나게 될 것이며, 그 시점에서 두 객체는 불필요해지므로 할당된 메모리는 회수되어야 함. 그러나 두 객체가 서로를 참조하고 있으므로, 참조-세기 알고리즘은 둘 다 가비지 컬렉션의 대상으로 표시하지 않음. 메모리 누수 발생.

    - 해결책: null을 할당해서 연결을 끊는 방법을 사용한다.
    - 대부분의 브라우저에서는 `Mark and sweep알고리즘`을 사용. 그래서 가비지컬렉터가 참조되지 않는 객체가 있을 때 동작하는 것이 아니라 접근 할 수 없는(닿을 수 없는) 객체 일 때 동작!

- 마크 앤 스위프(Mark-and-Sweep): 루트 객체(window 등)에서 접근 가능한 객체만을 남기고, 접근 불가능한 객체를 제거.
  - 방법
    roots(전역 번수)로 부터 시작하여 roots가 참조하는 Object들, roots가 참조하는 오브젝트가 참조하는 오브젝트들... 등을 표시하고 닿을 수 없는 오브젝트들에 대해 가비지 콜렉션을 수행
  - 추가
    Mark and Sweep을 할 때 모든 heap을 돌아다닐 수 없음. 왜냐하면 해당 작업이 일어날 때 JavaScript의 실행을 멈추기 때문. (작동시키는 thread는 다른 thread) 그래서 가능한 object들을 Mark하고 해당 object에 해당하는 heap 공간만을 확인. 그리고 다시 JS가 작동하고 이전에 멈췄던 곳에서부터 다시 Mark and Sweep를 작동시킴

현대 브라우저는 대부분 마크 앤 스위프 방식 기반의 최적화된 알고리즘을 사용
가비지 컬렉터는 항상 필요없어진 메모리만을 해제하지만, 모든 필요없어진 메모리를 해제하는 건 아님. 즉, ‘더 이상 필요없는 모든 메모리’가 아니라 ‘더 이상 필요 없는 몇몇 메모리’를 찾아냄. 이는 가비지 콜렉션 알고리즘의 한계점이 있기 때문

- 한계점
  - 어떤 객체가 실제로는 더 이상 쓰이지 않아도, 참조가 남아 있다면 GC는 이걸 해제하지 않음
  - 엔진마다 GC 타이밍이 다름 - 메모리 부족 상황이나 휴지 시간(idle time) 등에 맞춰 실행되므로,
    불필요한 객체가 메모리 상에 오래 남아있을 수 있음
    참조:
    [자바스크립트의 메모리관리](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)
    [2/ 메모리 관리와 가비지 콜렉션](https://feel5ny.github.io/2017/11/30/JS_02/)

## GC가 발생했는지 어떻게 알 수 있나요?

직접적으로 알 수는 없음. GC는 브라우저나 자바스크립트 엔진에 의해 자동으로 수행되며, 명시적인 트리거나 콜백은 존재하지 않음. 하지만 Chrome DevTools의 Memory 탭이나 Performance 프로파일링 도구를 통해 메모리 사용 추이나 스냅샷 비교를 통해 유추할 수는 있음.

## JS 메모리 누수 원인 4가지

- 전역 변수 남용: 전역 스코프에 선언된 변수는 앱이 종료되기 전까지 해제되지 않음
  - 데이터가 더이상 필요없어지는 시점에 null 처리하거나 재할당하여 메모리를 해제해주어야 함
- 이벤트 리스너 미제거: DOM 요소가 제거되어도 이벤트 핸들러가 남아 있으면 메모리가 해제되지 않음
- 클로저 남용: 클로저 내부에서 참조된 외부 변수가 수명이 늘어나 메모리 해제가 어려워질 수 있음
  - ex 타이머 clear 하지 않으면 null값을 지정하여도 타이머의 클로져가 외부 상황의 레퍼런스를 필요로 하여 메모리가 묶임
- DOM 참조 보관: 제거된 DOM을 여전히 참조하고 있는 경우 메모리 누수가 발생

[자바스크립트에서 메모리 누수의 4가지 형태](https://itstory.tk/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-4%EA%B0%80%EC%A7%80-%ED%98%95%ED%83%9C)

## 클로저와 메모리 누수 관계 설명

클로저는 함수가 외부 스코프의 변수에 접근할 수 있도록 참조를 유지. 이때 해당 변수가 계속해서 참조되면 GC가 이를 제거하지 못해 메모리 누수가 발생할 수 있음. 불필요한 클로저는 콜백 해제 또는 null 처리로 참조를 끊어야 함.

## 클로저를 사용하는 상황에서 메모리 누수를 어떻게 방지할 수 있나요?

- 클로저 내부에서 참조하는 외부 변수가 필요 없어졌을 때 null로 할당
- 함수가 종료되면 참조를 명시적으로 제거
- 또한 컴포넌트 기반 프레임워크에서는 언마운트 시 콜백 해제를 함께 해주기

## 브라우저에서의 메모리 최적화 방법은?

- 전역 변수 최소화: 불필요한 전역 선언은 누수 위험을 높입니다.
- 이벤트 리스너 정리: DOM 요소 제거 전 리스너도 함께 제거해야 합니다.
- 타이머(`setInterval`, `setTimeout`) 정리: 컴포넌트 언마운트 시 clear 처리 필요.
- DOM 참조 해제: 제거된 DOM을 변수로 계속 참조하지 않도록 합니다.
- 클로저 주의: 불필요한 외부 변수 참조 방지.

## WeakMap, WeakSet은 왜 사용하나요?

`WeakMap`과 `WeakSet`은 객체를 약한 참조(Weak Reference)로 저장하여, 객체가 더 이상 다른 곳에서 참조되지 않으면 GC가 제거할 수 있도록 함
이를 통해 명시적으로 삭제하지 않아도 메모리 누수를 방지할 수 있어, 예를 들어 비공개 데이터를 저장하거나 캐시를 구현할 때 적절

## `WeakMap`과 `Map`의 차이점은?

- `Map`은 모든 값(기본형 포함)을 키로 사용할 수 있고, 키가 강한 참조로 유지됨. 즉, 해당 키가 사용되지 않아도 메모리에서 제거되지 않음
- `WeakMap`은 오직 객체만을 키로 사용할 수 있으며, 해당 키가 다른 곳에서 참조되지 않으면 자동으로 GC에 의해 수거됨
- 따라서 `WeakMap`은 비공개 데이터를 안전하게 저장하거나 캐시 구현 시 유용
