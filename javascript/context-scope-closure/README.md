# 실행 컨텍스트 / 스코프 / 클로저

## var 와 let, const의 차이점은 무엇인가 (function scope와 block scope의 개념에서)

- `var`는 function scope를 가지며, 블록 내에서 선언하더라도 함수 전체에서 유효.
  - `var`은 재할당 가능
  - `var`는 호이스팅 시 undefined로 초기화 → 선언전에 참조 가능
- `let`, `const`는 block scope를 가지므로 `{}` 내부에서만 유효.
  - `let`은 재할당 가능
  - `const`는 재할당 불가능
  - `let`/`const`는 TDZ(Temporal Dead Zone)에 걸려 선언전에 참조 불가능.(ReferenceError)

## `const`로 선언된 객체의 속성은 변경할 수 있나요? 가능하다면 어떻게 하나요?

`const`는 변수 자체의 재할당을 막는 키워드라 변수에 저장된 참조(메모리 주소)를 바꿀 수는 없지만, 해당 참조가 가리키는 객체의 내부 속성은 변경 가능.
`const`는 변수의 참조값을 고정할 뿐, 그 참조값이 가리키는 객체의 내부 상태는 제어하지 않기 때문.

## 객체 자체를 불변하게 만들고 싶다면?

`Object.freeze()`를 사용하거나, 불변성을 유지하는 라이브러리(Immutability Helpers, Immer 등)를 활용

## TDZ란 무엇인가

TDZ는 변수가 선언되기 전까지 접근할 수 없는 영역을 말함. (`let`과 `const`는 호이스팅은 되지만 초기화되지 않아, 선언 이전에 접근하면 ReferenceError가 발생)

1. Hoisting 때문에 변수의 선언은 스코프 최상위에 위치 한 것과 동일하게 동작함
2. var로 선언 된 변수는 Hoisting 된 다음 `undefined`의 값으로 초기화 됨
3. let과 const의 경우 Hoisting 된 다음 초기화가 이루어지지 않음.
4. `let과 const가 Hoisting 되어 선언 된 다음, 초기화 되기까지의 구간`을 TDZ라고 부름
5. TDZ 구간에서 변수를 참조하려고 하면, 변수 초기화가 되지 않은 상태라서 에러가 뜸

## 호이스팅

Javascript의 모든 선언문이 해당 Scope의 최상단으로 옮겨진 것처럼 행동하는 자바스크립트의 특성을 말함. 모든 선언문은 런타임 이전에 먼저 실행되기 때문에 발생.
실제로 코드가 끌어올려지는 것은 아니며, 자바스크립트 Parser 내부에서만 끌어올려서 처리. (실제 메모리에서 변화는 없음)

- 코드의 가독성과 유지보수를 위해 호이스팅이 일어나지 않도록 한다.
  - 함수와 변수를 가급적 코드 상단부에서 선언하면, 호이스팅으로 인한 스코프 꼬임 현상은 방지 가능
  - let/const 사용하면 호이스팅 방지 가능
    - 하지만 ES6은 아직 어디에서든지 쓸 수 있는 상태가 아님 바벨같은 컴파일러로 ES5로 번역하면 let/const는 var이 됨. 따라서 아직은 var이 어떻게 동작하는지 이해해야함.

## 호이스팅의 종류

1. 함수 선언문의 호이스팅
   - 같은 이름의 선언문은 name : value로 scope에 저장되기때문에 나중 것으로 덮어 쓰기 됨.
   - 자바스크립트는 함수 실행 전 선언을 해석 및 초기화 (function Objcet 생성) → 표현식 처리 (메모리 공간 할당과 메모리 공간에 이름을 붙인다.) → 실행의 단계 이렇게 크게 2단계를 거치는데 , 함수 선언문 초기화 단계에서 function Object를 생성하고 scope에 할당함. 그렇게 때문에 어디에서도 함수를 호출할 수 있음.
2. 변수의 호이스팅
   1. var / let, const의 차이
   2. 함수 표현식 (var a = fucntion(){})은 undefined로 초기화 되기 때문에, 선언만 호이스팅 될뿐, 함수가 아닌 변수 취급 당함
3. 클래스의 호이스팅 (모던 자바스크립트 )
   - let 변수와 const 변수의 선언처럼, 호이스팅되고 uninitialized로 초기화
   - 그래서 클래스를 사용하려면, 클래스를 위에서 선언하고 사용해야됨

## 자바스크립트 엔진의 해석 순서

코드 실행 전, 전역 실행 컨텍스트가 생성되고 변수/함수 선언을 먼저 처리. 이후 라인별로 실행하며, 새로운 함수 실행 시마다 새로운 실행 컨텍스트가 콜 스택에 쌓임. 함수 실행이 끝나면 콜 스택에서 pop.

## 실행컨텍스트란 무엇이고 실행 컨텍스트 안에는 어떤 것들이 있나요?

자바스크립트의 코드가 실행되는 환경.

- 전역 컨텍스트 하나 생성 후에 함수 호출할 때마다 함수 컨텍스트가 생성.
- 컨텍스트 생성시 변수객체, 스코프 체인, this가 생성됨. 컨텍스트 생성 후

함수가 실행되는데 사용되는 변수들은 변수 객체 안에서 값을 찾고 없다면 스코프체인을 따라 올라가며 찾음. 함수 실행이 마무리되면 해당 컨텍스트는 사라짐. 페이지가 종료되면 전역 컨텍스트가 사라짐.

구성요소

- 렉시컬 환경(Lexical Environment) 컴포넌트
  - 현재 스코프 내의 식별자(변수, 함수 등)와 외부 환경을 기억하는 구조. 코드 작성 시점의 스코프를 기준으로 상위 스코프를 기억.
  - 환경 레코드
    - 선언적 환경 레코드
      - 기본 primitive type의 변수와 값을 만나면, k/v형태의 프로퍼티로 저장한다.
    - 오브젝트 환경 레코드
  - 외부 렉시컬 환경 참조
    - 함수 외부에 선언된 함수나 변수의 scope를 저장한다 → 이를통해 외부에 있는 함수나 변수를 하나의 실행 컨텍스트 안에 묶을 수 있음
- 변수 환경 (Variable Enviorment) 컴포넌트
  - 변수 환경은 복원을 위해서 존재. 다시 돌아왔을 . 변수환경의 값을 렉시컬 환경에 적용함으로써 초기값으로 돌아가기 위해서 존재
    - 변수환경 컴포넌트와 렉시컬 환경 컴포넌트의 초기값은 같음
- this 바인딩 컴포넌트 (This Binding) 컴포넌트
  - 함수안에서 this로 참조할 오브젝트를 담음(this로 참조할 오브젝트를 바인딩)
  - Scope를 사용하는 것 외에, this를 통해 외부에 위치한 변수의 값을 가지고 올 수 있음
  - function의 경우 default로 window 오브젝트를 참조.

## 렉시컬 환경이란?

ES5 실행 컨텍스트의 환경. '정적' 환경으로, 함수가 호출될때, 미리 환경을 만들어 두고 실행을 시작. 실행 컨텍스트가 하나의 실행의 묶음이라면, 하나의 환경적인 측면을 처리하는게 Lexical Environment.
Lexical Environment는 함수 선언, 블록문, catch절 같은 코드가 평가될 때 생성

- 순서
  - 엔진이 문자열을 읽다가, function 키워드를 만나게되면, function Object를 생성하고, [[Scope]]를 설정. (아직 함수 내부는 알 수 없음.)
  - 엔진이 function 키워드를 만났을때, 함수의 외부 Lexical Env 가 결정됨.
  - 함수가 호출되면, 방금 생성한 [[Scope]]를 execution context의 Lexical env component (LEC) (외부 렉시컬 환경 참조)에 설정.

## Scope는 무엇인가?

변수의 유효 범위.
자바스크립트는 정적 스코프(렉시컬 스코프) 기반. 즉, 선언 위치에 따라 스코프가 결정됨
스코프의 목적 : 스코프란 범위를 제한하여, 식별자 해결을 하기 위함

## ES5와 ES6의 스코프 차이는?

ES5는 '함수 단위의 스코프'
ES5에는 `var`만 있어 function scope만 존재했음
ES6는 '블록 단위의 스코프'
ES6부터 `let`, `const`가 도입되며 block scope 개념이 생기고, TDZ와 함께 예측 가능한 스코프 관리가 가능해졌음

## 스코프 체인이란?

스코프 체인은 식별자 검색을 위한 메커니즘으로 현재 실행 컨텍스트에서 변수를 찾지 못하면 상위 렉시컬 환경을 따라 올라가면서 변수/함수를 탐색하는 구조. 최상위는 전역 컨텍스트

ES3에서는 실행 컨텍스트와 관련있으며, 식별자 해결/결정을 위해 사용 됐었음

- ES3에서는 activation Obejct와 scope chain 두개를 이용해서 함수를 처리하기 때문에, Context 존재하다고 하기 애매
- es3는 함수 호출시에 scope chain을 동적으로 바꿨지만, ES5는 엔진이 해석하는 단계에서 함수의 환경을 결정함.
  - ES5에서는 식별자 해결/결정을 위해 Scope를 사용하지만, Scope chain을 사용하지 않는다.
- ES5에서는 하나의 context에 함수 실행에 필요한 모든 정보를 저장
- ES5의 lexical Env덕분에 엔진 속도가 비약적으로 상승했음 (ES3는 activation obj와 scope chain 2개가 load되야되는 반면, ES5는 Lexical Env 하나만 로드 되면 됨)
- 현재 존재하는 scope안에 변수가 없다면, 상위 scope를 타고 올라감
- Scope에서 이름을 찾기 위해, 스코프에 변수나 함수의 이름을 저장해둠. 값은 변경될 수 있지만, 이름은 변경되지 않음.
- Scope Chain은 Lexical Env를 원소로 하는 단방향 링크드 리스트이다. (ES5 기준)

## 식별자 해결이란?

변수나 함수를 참조할 때, 현재 렉시컬 환경 → 상위 렉시컬 환경을 따라 올라가며 해당 이름을 가진 식별자를 찾는 과정.

## 스코프 체인을 통해 식별자 해결을 하는 과정 & 프로토타입과의 관계

ES5에서의 식별자 해결은 Context에 저장된, Scope를 통해 해결

- 스코프 체인과 프로토타입 체인은 식별자를 찾기 위해 협업하는 관계
- 식별자를 찾을 때는 먼저 스코프 체인을 따라서 찾고,
  - 식별자와 바인딩 된 값이 객체라면, 그 객체의 프로토타입 체인을 따라서 속성을 찾음.
- 스코프 체인에서 식별자를 찾지 못하면, 전역 객체에서 찾게 되고,
  - 전역 객체에서 찾을 때는 프로토타입 체인이 동원됨

## Lexical Scope / 렉시컬 스코프 / 정적 스코프란?

- Lexical Scope(정적): 함수를 어디에서 선언 했는지에 따라 스코프가 결정 됨(자바스크립트 방식).
- Dynamic Scope(동적): 함수가 호출된 시점의 컨텍스트에 따라 상위 스코프 결정 (자바스크립트는 아님).

정적 스코프가 생성되는 이유:

- 엔진이 function 키워드를 만나면서, function object를 만듬
- 이때 [[Scope]]를 결정하게 되는데, 이때 만들어진 스코프를 Lexical Scope라고 함
  - 엔진이 function 키워드를 만났다고 실행되는건 아니고 한참뒤에나 실제 사용을 하게 되므로 저장하는것
- 이후 함수가 호출되면 실행 컨텍스트를 만들고 function Object가 생성될때 만들어진 [[Scope]]에 함수가 속한 영역을 저장한다 → 이것이 Lexical Scope

## Scope binding

식별자가 특정 스코프에 연결되는 과정을 의미. 자바스크립트는 렉시컬 바인딩을 따르며, 함수가 선언된 위치에 따라 상위 스코프가 결정됨.
바인딩의 대상은 프로퍼티의 이름 → 구조적으로 결속된 상태를 만드는것
Binding 시에 Scope가 결정됨. 그러므로 바인딩 시점이 굉장히 중요
Binding시에는, 이름만 저장하기 때문에, 식별자해결에 있어 동일한 이름을 사용할 뿐이지, 값과는 관계가 없음

1. Lexical Binding
   1. 함수가 호출되었을 때, 바인딩
   2. 초기화 단계에서 바인딩
   3. 표현식을 바인딩
2. Dynamic Binding
   1. 함수가 실행될때, 바인딩 / eval, with문을 만났을때 바인딩

## 스코프를 속일 수 있는 방법은? 혹은 동적으로 스코프를 생성할 수 있는 방법은?

- with과 eval을 이용해서, 정적 스코프를 동적으로 생성할 수 있음
  - with
    - JS엔진이 with 문을 만나면 scope를 생성
    - with문은 strict모드에선 에러가 발생 → use strict를 통해 with문의 사용을 배제할 수 있다.
  - eval
    - 문자열에 감싸진 코드를 인자로 JS 구문을 실행 사용하기 때문에, 막는 방법은 없음
    - 호출하는 위치와 방식에 따라, 실행 컨텍스트와 범위가 달라짐
      - 직접호출하지 않는경우 eval의 this는 글로벌 오브젝트
      - 직접 호출하는 경우 현재 실행 컨텍스트의 this
        ```tsx
        var foo = "global_foo";
        function directEval() {
          var foo = "local_foo";
          return eval("foo");
        }
        function indirectEval() {
          var foo = "local_foo";
          var f = eval; // 직접 eval을 호출하지 않고 eval의 참조를 호출한다.
          return f("foo");
        }
        directEval(); //--> 'local_foo'
        indirectEval(); //--> 'global_foo'
        ```

## eval과 with를 통해 스코프를 속일 수 있는데, 사용하지 않는 이유는?

- JS엔진은 성능향상을 위해 미리 코드를 컴파일 하는데, eval같이 동적으로 실행범위가 결정되는 코드는 미리 컴파일 할 수 없기 때문
- 또한 블랙박스이기때문에 디버깅에 안좋음
- 성능이 안좋음
- 보안에 취약 : XSS(Cross-Site Scripting) 공격 에 취약. eval() 이 코드를 오픈 시킬수있음
  참고 자료 : https://t.kazikai.net/115

## 클로저란?

클로저는 외부 함수의 변수(환경)를 내부 함수에서 기억하고 참조할 수 있는 개념. 스코프에 따라서 내부함수의 범위에서는 외부 함수 범위에 있는 변수에 접근이 가능하지만 그 반대는 실현이 불가능하다는 개념.주로 상태 유지, 은닉, 캡슐화에 사용.

1. 상태 유지

   가장 많이 사용되는 용도. 자신이 생성되었을 때 환경에 속한 변수를 기억하여 해당 변수의 최신 상태를 유지

2. 전역 변수 사용 억제

   전역 변수로 사용될 변수 값을 함수 안에 넣음으로써 의도치 않은 상태 변경을 방지할 수 있음.

3. 캡슐화, 은닉

   자바스크립트는 따로 private 생성자를 지원하지 않지만 closure를 이용해 private의 역할을 대신 할 수 있음

4. 커링

   커링이란 여러 인자를 입력받는 함수를 인자를 나눠서 받는 함수의 시퀀스로 변경하는 것. 커링은 함수의 재사용에서 용이하게 만듬. 인자 중 변하지 않는 값을 고정시키고 변하는 값을 변경하며 여러 함수를 생성할 수 있음.

클로저 특징

- 이미 생명주기가 종료되어 실행컨텍스트에서 outer함수가 제거되어도, inner함수를 통해 이미 제거된 변수에 접근할 수 있음. outer함수는 실행 컨텍스트에서 제거가 되지만, 렉시컬 환경까지 소멸하는게 아님. inner에서 참고하고 있기 때문!(누군가가 참조하고 있다면 메모리 공간을 함부로 해제 하지 않음)
- 이론적으로는 자바스크립트의 모든 함수가 상위스코프를 기억하고 있으므로, 이론적으로는 모든 함수가 클로저. 하지만, inner함수에서 상위 스코프의 변수를 참조하고 있지 않는다면 클로져라고 하지 않음
- 외부 함수의 변수 뿐만 아니라 파라미터에도 접근할수 있음.
- 외부함수가 내부 함수를 리턴한 후에도 내부에 접근할 수 있음.
- 다른 programming language에서는 함수의 로컬 변수는 함수가 실행되는 동안에만 존재하지만 자바스크립트에서는 함수가 closure을 형성하기 때문에 그렇지 않음. 함수와 lexical environment의 조합. 이 환경은 클로져가 생성될때 스코프 내부에 있던 모든 로컬 변수로 구성됨.

Performance

- closure가 필요하지 않을 때 closure를 만드는 것은 메모리와 속도에 악영향을 끼침. 예를 들어 새로운 object, class를 만들때 method는 object의 생성자 대신에 object의 프로토 타입에 있는 것이 좋음, 왜냐하면 생성자가 호출 될때 마다 method는 reassign 되기 때문

## 클로저 메모리 누수 예시

정보를 은닉하고, outer함수가 지속적으로 남아있어야하는 경우, 클로저는 필요함
클로저 내부에서 더 이상 필요하지 않은 DOM 참조를 계속 가지고 있을 경우, GC 대상에서 제외되어 메모리 누수가 발생할 수 있음. 클로저가 참조 중인 외부 변수에 불필요한 데이터가 없는지 관리가 중요.

- Outer 함수의 렉시컬 스코프를 저장하고 있으므로 메모리가 소모됨
- 그래서 클로저의 사용의 끝나면 참조를 제거하는 것이 좋음

## IIFE 사용 이유와 클로저와의 관계

IIFE (즉시실행되는 익명함수) 와 클로저를같이 사용하면 함수의 재사용과 정보 보호를 할 수 있음
IIFE는 선언과 동시에 실행되는 함수 표현식으로, 지역 스코프를 만들어 변수 오염 방지에 유용함. 내부에서 외부 변수를 참조하면 클로저가 형성되는데 반환된 내부 함수가 외부에서 사용되지 않으면 GC 대상이 되어 메모리 누수 위험이 적음.

## Global Object 란?

브라우저 환경에서는 `window`, Node.js에서는 `global` 객체가 전역 객체이며, 전역에 선언된 변수/함수는 이 객체의 속성으로 등록됨.
Global Object 자체가 스코프임. 즉 Global Scope도 1개 존재. 그래서 스코프 체인에 따라 식별자를 해결할때, 가장 마지막에 도달하는 Scope가 Global Scope
