# 비동기 & 동기

## Node js는 싱글스레드인가요? 멀티 쓰레드 인가요?

자바스크립트는 싱글 쓰레드이지만 노드는 멀티 쓰레드임.

Node.js는 기본적으로 싱글 스레드(이벤트 루프 기반)이지만, I/O 작업은 내부적으로 libuv를 통해 멀티 스레드로 비동기 처리됨. 또한 worker_threads 모듈로 명시적 멀티스레드도 가능

`libuv`: 비동기 I/O를 위한 이벤트 루프와 스레드 풀을 제공하는 C 기반 라이브러리

## 이벤트 루프에 대해서 설명, 동시성 모델에 대해서 설명

자바스크립트는 싱글 스레드 기반 언어. 함수를 실행하면 함수 호출이 스택에 순차적으로 쌓이고 스택의 맨위에서부터 아래로 한번에 하나의 함수만 처리 할 수 있음. 하지만, 자바스크립트에는 이벤트 루프라는것을 통해 동시성을 지원한다. (동시에 일어나는 것이 아니라 동시에 일어나는 것처럼 보이게 하는것!) 이벤트 루프는 콜 스택에서 실행 중인 게 있는지 확인하고, Event queue에 작업이 있는지 확인해서 콜스택이 비어있다면 이벤트큐 내의 작업이 콜스택으로 이동되어서 실행됨. 자바스크립트의 동시성과 비동기 처리의 핵심

## 콜 스택(Call Stack)과 태스크 큐(Task Queue)의 차이는 무엇인가요?

- `Call Stack`: 현재 실행 중인 함수들이 쌓이는 스택. 동기 작업이 여기에 쌓임.
- `Task Queue`: 비동기 작업이 완료된 후 콜백이 대기하는 공간
  - Microtask Queue: Promise, MutationObserver
  - Macrotask Queue: setTimeout, setInterval 등

## 동기/비동기 프로그래밍

- 동기: 코드가 순차적으로 실행되며, 다음 작업은 이전 작업이 끝나야 시작되는 방식
  - 설계가 매우 간단하고 직관적이나 시스템의 전체적인 효율은 저하된다고 할 수 있음
- 비동기: 시간이 오래 걸리는 작업을 위해 다른 작업들을 지연시키지 않고 다른 작업을 먼저 실행할 수 있도록 하는 방식

## 동기(synchronous) 함수와 비동기(asynchronous) 함수의 차이는?

동기 함수는 실행이 끝날 때까지 다른 작업을 중단시키고, 비동기 함수는 콜백/Promise 등을 활용해 작업 완료 시점에 실행을 위임함

## SetTimeout SetInterval

- setTimeout(fn, ms): 일정 시간(ms) 뒤 한 번 실행하는 메서드
- setInterval(fn, ms): 일정 시간(ms) 간격으로 반복 실행하는 메서드
- ClearInterval: setInterval로 반복하던 함수 멈춤
- 주의: 정확한 시간 보장 X, 이벤트 루프 상황에 따라 지연 가능

## 콜백 함수에 대해 설명해주세요.

1. 다른 함수의 인자로 전달되어, 해당 함수 내에서 실행되는 함수
2. 어떤 이벤트에 의해 호출되어지는 함수

자바스크립트는 promise가 등장하기 전에 비동기 처리를 위한 하나의 패턴으로 콜백함수를 사용했음. 비동기식 처리를 요청할 때 응답을 한 후, 다음 해야할 일을 알려주는 콜백이라는 함수를 함께 알려줌. 비동기식 요청 처리가 끝나면 콜백 함수를 호출하여 처리 결과 전달. (사용자가 함수를 호출하는 것이 아니라 일을 마친 시스템이 호출하는 형태이기 때문에 콜백이라고 불림. 이미 아까 응답을 했기 때문에 처리 결과를 함수 호출이라는 형태로 전달)
전통적인 콜백 패턴은 콜백 헬로 인한 가독성이 좋지 않음.
(비동기 작업을 처리할 때 콜백 함수 안에 콜백을 계속 중첩해서 작성하게 되어 코드의 가독성과 유지보수성이 떨어지는 현상 발생 가능)

## 프로미스(Promise)란 무엇이며, 언제 어떻게 사용하나요?

Promise는 비동기 작업의 성공/실패 결과를 표현하는 객체. 콜백헬 문제를 해결하기 위해 등장. (ES6부터 정식 지원)

- 상태
  - Pending(대기): 비동기 처리 로직이 아직 완료되지 않은 상태
  - Fulfilled(이행): 완료되어 프로미스가 결과 값을 반환해준 상태
  - Rejected(실패): 실패하거나 오류가 발생한 상태
- Promoise 생성자 함수를 통해 인스턴스화
- 비동기 처리
  - 성공하면 resolve 메소드를 호출해서 비동기 처리 결과를 후속처리 메소드로 전달.
  - 실패하면 reject 메소드를 호출해서 에러메시지를 후속처리 메소드로 전달.
- 후속처리메소드
  - .then(), .catch(), .finally() 다 Promise를 반환.
  - then 을 가지고 메소드 체이닝을 통하여 콜백헬 문제를 해결 할 수 있음
- 사용 예시
  - Ajax 요청
  - 비동기 타이머 처리
  - async/await을 쓰기 위한 기반 구조

## Promise chaining 에서 에러는 어떻게 핸들링하나요?

`.then().then()` 중간에 발생한 오류는 가장 가까운 `.catch()`에서 처리
최종 `.catch()`는 항상 체인의 끝에 위치해 전체 흐름을 감싸도록 구성해야 안전함.

```js
doSomething()
  .then((result) => doSomethingElse(result))
  .catch((err) => handleError(err));
```

## async await에 대해 설명

Promise를 더욱 쉽게 사용할 수 있도록 도와주는 ES8(ES2017) 문법.
Promise를 사용하면 결국 then 안에 코드가 묶이거나 error 처리를 위해 사용된 then, catch가 try, catch와 충돌이 나는 등의 문제가 발생. 이를 해결하기 위해 나온 것이 async, await.
async 함수는 항상 Promise를 반환하고, await 키워드는 Promise가 해결될 때까지 기다렸다가 그 결과를 반환 → 동기 코드처럼 비동기 흐름을 작성할 수 있음
async await를 사용할 경우 코드가 간결해지고 동기적인 코드흐름으로 개발이 가능해지나, 에러처리를 잡기 위해 try catch를 사용해야함

## Microtask와 Macrotask 차이는?

- Microtask: `Promise.then`, `MutationObserver` 등.
  - 이벤트 루프 1회 사이클마다 모든 마이크로태스크가 먼저 실행
- Macrotask: `setTimeout`, `setInterval`, I/O, UI 이벤트 등.
  - 다음 이벤트 루프 사이클에서 실행됨

## AJAX란 무엇인가요?

브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 `전체페이지를 새로고침 할 필요없이 필요한 일부분의 데이터만을 갱신할 수 있게 도와주는 자바스크립트 라이브러리.`
AJAX(Asynchronous JavaScript and XML)는 웹 페이지를 전체 새로고침하지 않고도 서버와 비동기적으로 데이터를 주고받을 수 있게 해주는 기술.
보통은 서버로부터 웹페이지가 반환되면 전체를 갱신해야하는데  / AJAX를 사용하면, 페이지 일부만을 갱신 가능. 즉, 갱신이 필요한 부분만 로드하여 갱신하면 되므로 빠르고, 부드러운 화면효과를 기대할 수 있음

## AJAX 요청이 완료되기 전에 DOM을 조작하려면 어떻게 해야 하나요?

AJAX는 비동기 요청이므로 요청이 완료되기 전에 DOM 조작이 가능. DOM을 먼저 렌더링하거나, 로딩 스피너 등을 먼저 표시한 뒤 요청이 완료되면 결과에 따라 DOM을 업데이트하는 방식으로 구현.

## fetch와 XMLHttpRequest의 주요 차이는 무엇인가요?

| 항목          | `fetch`                | `XMLHttpRequest`           |
| ------------- | ---------------------- | -------------------------- |
| 사용 방식     | Promise 기반           | 콜백 기반                  |
| 코드 가독성   | 간결하고 체이닝 가능   | 상대적으로 복잡            |
| JSON 파싱     | 자동 `.json()` 제공    | 수동으로 `JSON.parse` 필요 |
| 요청 취소     | `AbortController` 필요 | `.abort()` 메서드 제공     |
| 타임아웃 설정 | 직접 구현 필요         | 내장 타임아웃 기능 존재    |

대부분의 최신 프로젝트에서는 Promise 기반으로 깔끔하게 처리할 수 있는 `fetch`를 선호

## AJAX는 항상 비동기인가요? 동기로 쓸 수 있나요?

기본적으로 AJAX는 비동기로 설계되었지만, `XMLHttpRequest`에서는 동기 방식(`async = false`)으로 설정할 수 있음. 그러나 이 방식은 브라우저를 멈추게 하고 UX를 저하시켜, 최신 브라우저에서는 금지되었거나 사용을 권장하지 않음. `fetch`는 기본적으로 비동기이며, 동기 방식은 지원하지 않음.

## AJAX 요청에서 CORS 에러가 발생한 적이 있나요? 어떻게 해결했나요?

CORS(Cross-Origin Resource Sharing) 에러는 브라우저가 보안상 출처가 다른 서버에 요청을 보낼 때 허용되지 않은 경우 발생. 주로 프로젝트 초기나, 서버 셋팅 바꾸고 백엔드 api 호출할때, 많이 생겼는데
이를 해결하려면:

- 서버 측에서 응답 헤더에 `Access-Control-Allow-Origin`을 설정
- 프록시 서버(Nginx 등)나 `devServer.proxy` 설정으로 우회할 수 있음.
- 개발 중이라면 크롬의 `-disable-web-security` 플래그를 이용해 테스트할 수는 있음(실제 서비스에서는 절대 사용하면 안 됨. 보안이슈)

## AJAX 요청 중 중복 요청이 생기는 경우 어떻게 처리하시나요?

- 버튼 비활성화: 요청 중에 버튼 비활성화로 UI에서 차단
- 플래그 사용: 요청 중인 상태를 `isFetching` 등으로 관리
- AbortController: `fetch`에서는 이전 요청을 취소하는 방식
- Debounce/Throttle:

  - debounce: 마지막 이벤트 발생 후 일정 시간 지나면 실행

    - 빈번한 이벤트를 하나로 묶어서 처리
    - 검색창 자동완성
    - window resize
    -

    ```js
    function debounce(fn, delay) {
      let timer;
      return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    window.addEventListener(
      "resize",
      debounce(() => {
        console.log("resized!");
      }, 300)
    );
    ```

  - throttle: 일정 시간마다 한 번씩만 실행

    - 주기적으로 이벤트 실행을 제한
    - 무한스크롤
    - 버튼 연속 클릭 방지
    -

    ```js
    function throttle(fn, interval) {
      let lastTime = 0;
      return function (...args) {
        const now = Date.now();
        if (now - lastTime >= interval) {
          lastTime = now;
          fn.apply(this, args);
        }
      };
    }

    window.addEventListener(
      "scroll",
      throttle(() => {
        console.log("scrolled!");
      }, 200)
    );
    ```

## AJAX 요청이 실패했을 때 사용자에게 어떻게 피드백을 주시나요?

- 에러 메시지 UI 출력: 토스트나 모달, 알림 영역 등을 활용해 사용자에게 에러 알림
- 로딩 스피너 제거: 요청 실패 시 스피너 제거로 사용자 혼란 방지
- 재시도 버튼 제공: 사용자가 직접 재시도할 수 있는 기회 제공
- console.log/logging: 개발 단계에서는 디버깅, 운영에서는 로그 서버로 전송

## fetch와 axios의 차이점은 무엇이며, 어떤 상황에서 어떤 것을 선호하시나요?

| 항목            | fetch                       | axios                   |
| --------------- | --------------------------- | ----------------------- |
| 기반            | 브라우저 내장 API           | 외부 라이브러리         |
| JSON 자동 파싱  | 수동 `.json()` 호출 필요    | 자동 처리               |
| 요청 취소       | `AbortController` 필요      | `CancelToken` 내장      |
| 인터셉터 기능   | 직접 구현해야 함            | 요청/응답 인터셉터 제공 |
| 브라우저 호환성 | 구형 브라우저 polyfill 필요 | 더 광범위하게 지원      |
| 기본 헤더       | 적음                        | JSON 등 기본 설정 포함  |

- axios는 설정과 에러 핸들링이 편리하여 대규모 프로젝트나 요청이 복잡한 경우에 선호
- fetch는 간단한 프로젝트나 외부 의존 없이 가볍게 쓸 때 적합

## WebWorker

([참고](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API))
자바스크립트의 메인 스레드와 별개로 동작하는 백그라운드 스레드. UI를 차단하지 않고 무거운 연산을 처리할 때 사용
메인 스레드에서 워커 객체를 생성하면 워커 스레드와 메시지 기반으로 통신이 가능.

워커 스레드에게 `postMessage`를 통해 처리하는 데 오래 걸리는 작업의 실행을 요청하면 워커 스레드가 이를 실행. 이를 통해 메인 스레드가 블록되는 것을 막을 수 있음. 워커 스레드는 작업이 완료되면 역시 `postmessage`를 통해 결과 완료 메시지를 전송하고, 메인 스레드에선 이를 통해 또 다른 작업을 할 수 있게 됨
메인 스레드와 워커 스레드는 메시지 기반으로만 통신 가능하다는 것이 웹 워커의 한계. 즉, 워커는 직접 DOM이나 메인 스레드의 콘텍스트에 접근할 수 없음 → 그래서 아직 좀 느리다고 느껴짐
