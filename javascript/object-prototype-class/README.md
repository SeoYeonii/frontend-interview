# 객체 & 프로토타입 & 클래스

## 프로토타입이란?

자바스크립트는 프로토타입 기반 언어로, 객체 간의 상속을 구현하기 위해 사용됨. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 개체로서 다른 객체에 공유 프로퍼티를 제공. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있음.

- 모든 객체들은 메소드와 속성들을 상속받기 위해 프로토 타입 객체를 가지고 있음
- 객체가 값을 공유하면서 메모리를 아낄 수 있음
- Prototype의 목적
  - 프로퍼티의 공유
    - Prototype객체는 생성자 함수에 의해 생성된 각각의 객체에 공유할 수 있음
  - Prototype의 확장
    - prototype 객체에 프로퍼티를 추가하여 확장할 수 있음
  - instance의 상속
    - 자바스크립트의 상속은 프로토 타입확장의 개념

객체는 자신을 생성한 생성자의 `prototype`에 대한 참조를 내부 슬롯 `[[Prototype]]`에 저장함. 이 구조 덕분에 객체는 자신에게 없는 프로퍼티나 메서드를 상위 프로토타입 체인을 통해 탐색할 수 있음.

https://www.nextree.co.kr/p7323/

## 프로토타입 체이닝이란?

객체에서 원하는 프로퍼티를 찾지 못하면, 프로토타입 체인을 따라 상위 객체로 탐색. 이 연결 구조를 "프로토타입 체이닝"이라고 하며, 이는 상속의 기반이 됨.

즉, 식별자 중에서도 어떤 객체의 속성(프로퍼티)를 찾아내는 매커니즘. 객체의 프로퍼티에 접근하려고 할때, 해당 객체에 접근하려는 프로퍼티가 없다면, [[Prototype]] 내부 슬롯 참조에 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색. prototype object를 확인하면서 prototype object가 null이 될때까지 탐색.

## 프로토타입의 상속이란?

객체가 다른 객체의 속성과 메서드를 물려받을 수 있게 하는 방식. 생성자 함수의 `prototype`에 메서드를 정의하면 해당 생성자로 만든 모든 인스턴스는 그 메서드에 접근할 수 있음

- 프로토타입 체이닝을 통해 상속할 수 있다.
- 방법
  1. 이전 방법 → const a = Obect.Create(기존에 존재하는 Obect)
  2. ES6 이후 → const a = Object.setPrototypeOf(새로운 Object, 기존 Object)

## Object 프로토타입은?

`Object.prototype`은 모든 객체의 최상위 프로토타입임. 이 안에 정의된 `toString`, `hasOwnProperty`, 같은 메서드는 모든 객체에서 접근할 수 있음.

## Class의 최상단 프로토 타입은 무엇인가?

`Object.prototype`
모든 Function, class의 최상단 prototype은 Object 그 위는 `null`

## JavaScript의 프로토타입 기반 상속(prototypal inheritance)은 어떻게 동작하나요?

자바스크립트는 함수 기반 상속 사용. 객체는 `__proto__`로 상위 프로토타입 객체를 참조하고, 메서드나 속성이 없을 경우 이 체인을 따라 상속받은 것처럼 동작.

## 호스트 객체(Host Object)와 네이티브 객체(Native Object)의 차이는 무엇인가요?

- Native Object는 JS 엔진에 내장된 객체(`Object`, `Array`, `Date`, `RegExp` 등)를 의미
- Host Object는 JS가 실행되는 환경(브라우저나 Node.js 등)에서 제공하는 객체(`window`, `document`, `XMLHttpRequest`)를 의미

## 내장 객체(Built-in Object)를 확장하는 것의 장단점은 무엇인가요?

장점은 모든 객체에 기능 추가가 가능하지만, 단점은 네이티브 메서드와 충돌 가능성이 있어 유지보수에 악영향을 줄 수 있음.

## 클래스 vs 함수 생성자

ES5에서는 생성자 함수로 객체를 만들었지만, ES6의 `class`는 문법적 설탕(Syntactic Sugar)일 뿐 내부 동작은 여전히 프로토타입 기반. 다만 `class`는 선언이 호이스팅되지 않고, `new` 없이 실행할 수 없어 더 명확함

## 생성자 함수와 new 키워드

`new` 키워드로 생성자 함수를 호출하면:

1. 빈 객체 생성
2. `this`에 바인딩
3. 프로토타입 연결
4. 명시적 반환이 없으면 this 반환

## 정적(static) 클래스 멤버를 정의하는 이유는 무엇인가요?

인스턴스와 관계없이 공통적으로 사용되는 유틸성 메서드나 상수는 static으로 정의. 이는 메모리 절약과 가독성 면에서 유리함.

## 싱글톤 패턴이란?

하나의 인스턴스만 생성되도록 제한하는 디자인 패턴. 전역 상태 관리, 설정 객체, 공통 로거 등에 활용되며, 자바스크립트에서는 클로저나 클래스 기반으로 구현할 수 있음
하나의 인스턴스로만 동작해야 하는 공통 상태, 리소스, 설정 등을 효율적으로 관리할 수 있기 때문에 사용
ex):

- 전역 설정 객체(Config)
- 로그 시스템(Logger)
- DB 연결(Connection Pool)
- 전역 상태 관리(Store)
  : 여러 번 만들면 메모리 낭비, 충돌, 일관성 문제 발생!
  : 싱글톤으로 만들면 한 번만 만들고, 모두가 그걸 공유해서 사용

## Object.create(), Object.assign() 차이

- `Object.create(proto)`는 지정된 객체를 프로토타입으로 하는 새 객체를 생성
- `Object.assign(target, source)`는 얕은 복사 방식을 통해 객체를 합침.

## ES6 클래스와 ES5 함수 생성자의 차이는 무엇인가요?

- 클래스는 `extends`, `super` 등 명확한 문법을 제공
- 생성자 함수는 프로토타입을 수동으로 설정해야 함
- 클래스는 호이스팅되지 않으며, 엄격 모드(`strict mode`)가 자동 적용됨

## 이터레이션 프로토콜

직접 메소드를 작성하거나, 프로토타입 체이닝으로 상속받은 Symbol.iterator 메소드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환하는 규약. 이 규약을 지키면 이터러블 프로토콜. 이터러블 프로토콜을 준수한 객체를 이터러블 하다고 함.

- 이터러블은 for..of + 스프레드 문법, 구조분해할당이 가능
- 이터러블의 Symbol.iterator를 호출하면, 이터레이터 프로토콜을 준수한 이터레이터를 반환.

  - 이터레이터는 next 메소트를 가지고 있고, value와 done 프로터피를 갖는 이터레이터 리절트 객체 반환

    - 코드

      ```tsx
      const a = [1, 2];

      const iterator = a[Symbol.iterator]();

      iterator.next(); // {value: 1, done: false}
      iterator.next();
      ```
