# 자바스크립트 기본

## JS 타입에는 어떠한 것들이 있나요? (primitive / reference)

- `Primitive type:` Undefined, Null, Boolean, Number, BigInt(`2 ** 53 - 1`(Number의 최대 안전 정수)을 초과하는 정수를 정확하게 표현할 수 있는 타입), String, and Symbol으로 7가지
- `Reference type`은 Object. Object는 built-in type이며 function, array 모두 object로 구현되어 있음.

원시 타입은 값 자체를 저장하며, 참조 타입은 메모리 주소(참조)를 저장. 원시값은 할당한 변수의 값을 변경하면 참조값 역시 변하게 되지만 Reference type을 Immutable하게 재할당하지 않는다면 참조값은 그대로.

## Symbol이란?

`Symbol`은 ES6에 추가된 고유하고 변경 불가능한 값. 주로 객체의 고유한 프로퍼티 키로 사용되며, 다른 값과 절대 중복되지 않음.

Symbol()로부터 반환되는 모든 심볼 값은 고유함. 심볼 값은 객체 프로퍼티(object properties)에 대한 식별자로 사용될 수 있고, 이것이 심볼 데이터 형식의 거의 유일한 목적.

## null과 undefined, undeclared의 차이는 무엇이고 이 상태는 어떻게 확인할 수 있나요?

`typeof`를 활용하면 이 세 가지 상태를 안전하게 구분할 수 있음

- `undefined`는 접근 가능한 스코프에 변수가 선언은 되었으나, 아무런 값도 선언되지 않은 경우
  - undefiend는 데이터 타입이자 값을 나타냄. 정의되지 않은 것
  - typeof undefined === “undefined”
- `null`은 값이 "비어있음"을 개발자가 명시적으로 표현할 때 사용.
  - typeof null === object 'true' → (자바스크립트 초기 오류 - 수많은 이유로 인해 안 고친다고 함)
- `undeclared`는 변수 자체가 선언되지 않은 상태이며, 접근 시 ReferenceError가 발생.

  - typeof x === 'undefined’ 또는 `try { x } catch (e) {}`
  - x 에 접근하면 reference error 발생

## `typeof`, `instanceof`의 차이

- `typeof`: 원시 타입을 구분할 때 주로 사용
- `instanceof`: 객체가 특정 생성자 함수로부터 생성되었는지를 판별할 때 사용. 프로토타입 체인을 따라 올라가며 검사.

## `Object.is()`와 `===` 차이

둘 다 엄격한 비교를 하지만, `Object.is()` 가 더 정밀한 동일성 비교가 필요할 때 사용.

- NaN을 비교할 때
  - `===` : false
  - `Object.is()` : true
- +0, -0을 비교할 때
  - `===` : false
  - `Object.is()` : true

## 객체의 얕은 복사와 깊은 복사란?

`얕은복사`: 객체의 1단계 프로퍼티만 복사하고, 내부 중첩 객체는 여전히 원본 객체와 참조를 공유
`깊은 복사`: 는 객체 내부의 중첩 객체들까지 모두 새로 복사하여 완전히 독립적인 객체를 생성. 따라서 깊은 복사는 원본과 복사본이 완전히 분리된 메모리 공간을 가지며, 복사 후에 값을 변경해도 서로 영향을 주지 않음.

## 깊은 복사 방법

- `JSON.parse(JSON.stringify(obj))`
  간단하지만 함수, undefined(null로 바뀜), 순환참조(구조를 직렬화할 수 없어서 TypeError)가 있으면 부작용 발생
- 재귀 함수로 직접 구현
- `structuredClone()` (최신 브라우저 지원)
- 라이브러리 사용: `lodash.cloneDeep`

## `Object.assign()`과 스프레드 연산자(`...`)의 얕은 복사 차이점?

둘 다 얕은 복사(shallow copy)방식. 즉 1단계 프로퍼티만 복사하며, 참조형(객체/배열)의 내부 값은 복사하지 않고 참조만 함.
스프레드 연산자는 간단하지만 Symbol 프로퍼티나 프로토타입 복사가 안 됨. 반면 `Object.assign()`은 그런 것까지 복사 가능하지만, 덮어쓰는 방식이라 주의 필요.

- Object.assign(target, ...sources) →`target`에 복사되므로 프로토타입 유지 가능
- `{ ...source }` 또는 `[ ...source ]` → 새로운 객체이므로 프로토타입dl 안 복사됨

## 깊은 복사 시 성능 이슈는 어떻게 해결할 수 있을까?

성능을 고려해야 할 경우, 깊은 복사 시 라이브러리 활용을 추천. 상황에 따라 `structuredClone()`(표준내장기능 but 최신브라우저)을 쓰거나, 순환 참조가 있다면 `lodash.cloneDeep()` 사용.

깊은 복사는 모든 하위 객체까지 재귀적으로 복사하기 때문에 객체가 크거나 깊이가 깊은 경우 성능 저하가 발생할 수 있음.`JSON.parse(JSON.stringify(obj))`는 성능 저하 + 순환 참조 문제 있음.

## 구조 분해 할당은 얕은 복사일까 깊은 복사일까?

얕은 복사임. 구조 분해 할당은 객체/배열의 참조만 분리해서 새로운 변수에 할당. 복사된 변수는 내부 객체의 참조를 공유.

## primitive type에서 빌트인 메소드를 사용할 수 있는 이유는?

자바스크립트에서 primitive type은 객체가 아니지만, 메서드를 호출할 때 자동으로 해당 타입의 래퍼 객체로 일시적으로 변환됨(ex: `const str = 'hello';` → `new String('hello');` 로 자동 박싱되어서 실행 후 원시 값으로 돌아오는것.)이 과정을 통해 빌트인 메서드에 접근할 수 있게 됨

## `==`와 `===`의 차이점은 무엇인가요?

- `==`는 타입 변환을 허용하며 비교
  - 피연산자가 서로 다른 타입이라면 타입을 강제로 변환하여 비교한다
- `===`는 타입까지 엄격하게 비교
- 둘 다 객체에 관해서는 동일 객체 참조시에만 true를 반환한다
- ==은 타입까지 검사한 후, 형변환하기 때문에 실제적으로는 1마이크로초정도 느림
  예외
- NaN은 그 자신과도 다름 NaN !== NaN

## 명시적 형변환과 묵시적 형변환의 차이점은?

명시적 형변환은 개발자가 의도적으로 타입을 변환하는 것,
묵시적 형변환은 자바스크립트가 자동으로 타입을 변환하는 것

## 타입 강제 변환이란 무엇인가요? JavaScript에서 타입 강제 변환을 신뢰해서 생기는 흔한 문제점은 어떤 것들이 있나요?

타입 강제 변환이란, 자바스크립트에서 서로 다른 타입 간의 연산이 일어날 때 자바스크립트 엔진이 자동으로 타입을 변환하는 과정을 말함. (즉, 묵시적(암묵적) 형변환)

- 예상과 다른 비교 결과
  - `null == 0      // false`
  - `null == undefined // true`
- 그로 인한 버그 유발

자바스크립트는 타입이 느슨한 언어이기 때문에 묵시적 형변환이 자주 발생. 이러한 타입 강제 변환은 예측하기 어려운 동작을 만들 수 있기 때문에, 실무에서는 ===와 같이 명시적 비교를 사용하고, 명확한 타입 체크를 통해 안정성을 높이는 것이 좋음.

## JS에서 배열이란?

자바스크립트의 배열은 일반적인 배열의 동작을 흉내낸, 인덱스를 프로퍼티 키로 갖고 length를 프로퍼티로 갖는 특수한 객체.
해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우, 일반적인 배열보다 성능적인 면에서 느릴 수 밖에 없는 구조적인 단점을 갖음. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있음.
인덱스로 배열 요소에 접근할 때 일반적인 배열보다 느릴 수 밖에 없는 구조적인 단점을 보완하기 위해 대부분의 모던 자바스크립트 엔진은 배열을 일반 객체와 구별하여 보다 배열처럼 동작하도록 최적화하여 구현되어 있음

## 자바스크립트의 배열이 실제 자료구조 배열이 아닌데 그 이유는?

자바스크립트 배열은 정적 메모리 공간을 사용하는 C언어나 Java의 배열과 달리, 동적 크기 변경이 가능한 객체. 또한 자바스크립트의 배열은 실제 자료구조의 배열과 다르게 HashMap으로 구현되어 있음. 이 HashMap을 구현하기 위해서는 연결리스트로 구현하게 되는데 연결리스트에서 값을 찾기 위해서는 탐색해나가면서 값을 찾는 불상사가 발생할 수는 있음. 하지만 요소의 삽입/삭제가 자유롭고 이러한 유연성과 편의성을 위해 설계된 구조임.

## 객체의 속성이나 배열의 요소를 순회할 때 어떤 언어 구문을 사용하시나요?

객체는 주로 for...in 문을, 배열은 for, for...of, forEach()를 주로 사용.

- for: 가장 전통적인 루프
- for...in: 객체의 key를 순회 (배열에 사용 시 index로 순회)
- for...of: 이터러블(배열, Set, Map 등)의 값을 순회
- Object.keys(obj): 객체의 키 배열 반환
- Object.entries(obj): [key, value] 쌍 반환
- Array.forEach(): 배열의 각 요소에 대해 콜백 실행

## `Array.forEach()` 루프와 `Array.map()` 메서드의 주요 차이점은 무엇이며, 상황에 따라 어떤 것을 선택하나요?

- `forEach()`: 요소에 대해 side effect를 실행할 때 사용, 값을 반환하지 않음
- `map()`: 새로운 배열을 반환, 요소 변환 목적
  값을 가공해서 새 배열이 필요할 땐 `map()`, 단순 반복은 `forEach()`

## 배열을 순회할 수 있는 다른 주요 메서드들에는 어떤 것들이 있나요?

- filter(): 조건을 만족하는 요소 필터링
- reduce(): 누산값 계산 (예: 합계)
- find() / findIndex(): 조건을 만족하는 첫 요소 / 인덱스 찾기
- some() / every(): 하나라도 / 모두 만족 여부

## 삼항 연산자에 대해 설명해주세요.

- 간단한 조건문을 짧은 형태로 표현할 수 있어 가독성이 좋음
- 너무 중첩되면 오히려 가독성 저하 우려

## JavaScript에서 `while` 루프와 `do-while` 루프의 차이점은 무엇인가요?

- while: 조건이 참이면 실행 → 조건이 거짓이면 한 번도 실행 안됨
- do-while: 한 번 무조건 실행 후 조건 검사 → 최소 1번은 실행됨

## 자바스크립트 메모리 구조

- 스택 (Call Stack): 함수 실행 컨텍스트, 원시 타입 변수 저장. 작고 빠름
- 힙 (Heap): 객체, 배열, 함수 등 참조 타입 저장. 크고 느림
